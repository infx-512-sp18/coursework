webpackJsonp([13],{XAv9:function(e,t,a){"use strict";var n=function(){var e=this.$createElement;this._self._c;return this._m(0)};n._withStripped=!0;var r={render:n,staticRenderFns:[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("main",{attrs:{id:"main",tabindex:"-1"}},[a("h1",[e._v("Javascript AJAX")]),a("p",[a("iframe",{attrs:{width:"560",height:"315",src:"https://www.youtube.com/embed/2Ky2ab30Imw?rel=0",frameborder:"0",allow:"autoplay; encrypted-media",allowfullscreen:""}})]),a("p",[e._v("Now that you know how to create page content from data stored in a local variable, the next logical step is to learn how to fetch those data dynamically from a web service. This allows you to get up-to-date data each time your page loads, and even automatically refresh those data while the user remains on the page. JavaScript allow us to make requests to other web services, and process the results, without navigating or refreshing the page.")]),a("h2",{attrs:{id:"sec-ajax"}},[e._v("AJAX")]),a("p",[e._v('Back in the early days of the web (early 1990s), all data fetching and template merging happened on the server. Web browsers received fully-merged static HTML pages, and if you wanted fresher data, you had to refresh the page. If you wanted to send data back to the server, you filled out a form and let the browser submit the form to the server, where the data were processed and a new response page was generated. At that time, browsers were more like the "dumb terminals" of the mini-computer era, and all the real work happened on the server-side.')]),a("p",[e._v("JavaScript was added to web browsers starting in 1995, which made it possible to execute code on the client-side. But that code couldn't do very much until 1997, when both Netscape Navigator and Internet Explorer added the Document Object Model (DOM). Now one could conceivably build page content from data, but the data still had to be included in the initial set of files downloaded for the page. Refreshing the data still required a full page refresh.")]),a("p",[e._v("In the late 1990s, Microsoft started building a web-based version of their email and calendaring application Outlook, and they wanted a way to check for new mail and send new messages without triggering a full page refresh. Initially they toyed around with using a hidden\n      "),a("code",[e._v("<iframe>")]),e._v(" element, but the technique was clumsy and full of potential security issues. So they eventually proposed a new programming interface that would let JavaScript make an asynchronous HTTP request back to the web server from which the page came, and process the results once they returned. In response, the Internet Explorer team added a new global object named\n      "),a("code",[e._v("XMLHttpRequest")]),e._v(", which could do just that.")]),a("p",[e._v("The name of the object began with\n      "),a("code",[e._v("XML")]),e._v(" because at that time XML was all the rage, and the Outlook Web Access team figured they would encode data transmitted from the server to the client in XML. The\n      "),a("code",[e._v("XMLHttpRequest")]),e._v(" object would let them make an HTTP request to their server, and would automatically parse the returned data as XML so that they could work with it in their JavaScript. Since HTML was a variant of XML, they could use the same DOM interface when working with the returned data.")]),a("p",[e._v("When I first saw this in action, my jaw hit the floor. Up until that point, the web was a pretty mediocre application platform, barely better than what we had in the 1980s with mini-computers and dumb terminals. Now with the\n      "),a("code",[e._v("XMLHttpRequest")]),e._v(" object, we could build rich, interactive graphical client-side applications, like we had been building on desktop GUI operating systems like Windows, but with no installation step required. A user could simply navigate to a web site, and start using the downloaded application.")]),a("p",[e._v("This technique quickly became popular, and was given a name:\n      "),a("strong",[e._v("AJAX")]),e._v(", which was an acronym for\n      "),a("strong",[e._v("A")]),e._v("synchronous\n      "),a("strong",[e._v("J")]),e._v("avaScript\n      "),a("strong",[e._v("A")]),e._v("nd\n      "),a("strong",[e._v("X")]),e._v("ML. The \"Asynchronous\" part came from the fact that HTTP requests needed to be done asynchronously so that they didn't block the rest of your JavaScript. Since JavaScript is single-threaded, they couldn't just pause all of your script while waiting for the server to respond (which could take a while on a slow network). If the user clicked something in the meantime and your click event listener function didn't run, the user would think that the application was broken. So the HTTP request is done asynchronously, and your code provides a callback function, which is invoked once the server responds.")]),a("p",[e._v("By the mid-2000s, all major web sites were adding AJAX-based functionality, and new web applications were architected entirely around AJAX. These new application architectures were more reminiscent of the client-server era, where servers exposed Application Programming Interfaces (APIs) that returned and accepted\n      "),a("em",[e._v("raw data")]),e._v(", encoded in some sort of easily interchanged format. Transforming that data into something a user could see was the job of the client application, and one could build many types of client applications against the same server. Since only data flowed back and forth over the network and not a presentation language like HTML, one could build both a web client and a native desktop client that spoke to the same server. As soon as smart mobile devices came along, they became just one more type of client application, interacting with the same server APIs.")]),a("h2",{attrs:{id:"sec-json"}},[e._v("JSON")]),a("p",[e._v("In a client-server architecture, the client and server applications are commonly implemented in different programming languages, so the data that is sent between them must be encoded into a format that is easy to generate and parse by all languages. In the late-1990s and early-2000s, the encoding format of choice was XML, but JavaScript developers became frustrated with how difficult it was to work with XML data in the web browser. In contrast, JavaScript arrays and objects were very easy to work with, and there was already a simple text-based format for declaring those that any language could consume, so why not use that instead?")]),a("p",[e._v("The result was the\n      "),a("strong",[e._v("JSON")]),e._v(" encoding scheme, which stands for\n      "),a("strong",[e._v("J")]),e._v("ava\n      "),a("strong",[e._v("S")]),e._v("cript\n      "),a("strong",[e._v("O")]),e._v("bject\n      "),a("strong",[e._v("N")]),e._v("otation. The format is much simpler and more compact than XML, and it can be parsed directly into native JavaScript arrays and objects. It also supports a wider set of value literalsâ€”all attributes and element content in XML must be encoded as a string so extra meta-data is required to indicate the actual data type (number, boolean, etc). JSON defines a syntax for literal strings, numbers, booleans, and nulls. ")]),a("p",[e._v("JSON was also very familiar to JavaScript developers, as it looks almost identical to the way one declares arrays and objects in code. For example, here is a JSON-encoded object:")]),a("pre",[a("code",{staticClass:"json language-json"},[e._v('{\n    "id": 42,\n    "fname": "John",\n    "lname": "Doe",\n    "active": true,\n    "description": null\n}')])]),a("p",[e._v("The only real difference between JSON and a JavaScript object declaration is that the property names\n      "),a("strong",[e._v("must")]),e._v(" be wrapped in quotes, even if they are legal JavaScript identifiers. In a JavaScript object declaration, we can omit the quotes around property names that are legal identifiers, but it also doesn't hurt to include the quotes.")]),a("p",[e._v("Note that the value for the\n      "),a("code",[e._v('"id"')]),e._v(" property is a literal number, so it's included without quotes. This tells any program parsing this data that the value is numeric and should be parsed as such. Similarly, the value for\n      "),a("code",[e._v('"active"')]),e._v(" is a boolean literal\n      "),a("code",[e._v("true")]),e._v(", which will be parsed into a boolean value (as opposed to a string or a number). And the value for\n      "),a("code",[e._v('"description"')]),e._v(" is a literal\n      "),a("code",[e._v("null")]),e._v(", which will be parsed into a null data type.")]),a("p",[e._v("JavaScript has built-in support for generating and parsing JSON. To parse the JSON above, you can use\n      "),a("code",[e._v("JSON.parse()")]),e._v(":")]),a("pre",[a("code",{staticClass:"javascript language-javascript"},[e._v('var json = "..."; //JSON-encoded string from above\n\n//parse the JSON string into a JavaScript object\n//`obj` will be a native JavaScript object with\n//the same properties as you see in the JSON\nvar obj = JSON.parse(json);')])]),a("p",[e._v("And to generate JSON, you can use\n      "),a("code",[e._v("JSON.stringify()")]),e._v(":")]),a("pre",[a("code",{staticClass:"javascript language-javascript"},[e._v('//create a JavaScript object\nvar obj = {id: 43, fname: "Jane", lname: "Lee"};\n\n//convert to JSON-encoded string\nvar json = JSON.stringify(obj);')])]),a("p",[e._v("JSON quickly displaced XML as the data-encoding format of choice for web applications, and\n      "),a("a",{attrs:{href:"http://www.json.org/"}},[e._v("parsers were developed for all major programming languages")]),e._v('. We still refer to the general technique as "AJAX", but it\'s rare to find a web application these days that uses XML as the primary data-encoding format.')]),a("h2",{attrs:{id:"sec-thefetchfunction"}},[e._v("The\n      "),a("code",[e._v("fetch()")]),e._v(" Function")]),a("p",[e._v("The\n      "),a("code",[e._v("XMLHttpRequest")]),e._v(" object allows JavaScript developers to request JSON or XML-encoded data from the server, but the programming interface it exposed is quite complex to use. For example, here is the code necessary to make a simple request for some data:")]),a("pre",[a("code",{staticClass:"javascript language-javascript"},[e._v('//create a new XMLHttpRequest object\nvar request = new XMLHttpRequest();\n\n//configure it to do an asynchronous GET request for some URL\nrequest.open("GET", "/my/data/url", true);\n\n//add a listener for the "load" event, which\n//will happen when the data returns\nrequest.addEventListener("load", function() {\n    if (request.status >= 200 && request.status < 400) {\n        // Success!\n        var data = JSON.parse(request.responseText);\n    } else {\n        // We reached our target server, but it returned an error\n        //handle error...\n    }\n});\n\n//add a listener for the "error" event, which\n//will happen if there was a network error\nrequest.addEventListener("error", function() {\n    //handle error...\n})\n\n//finally, send the request to the server\nrequest.send();')])]),a("p",[e._v("That's quite a lot of code for a rather simple operation. Understandably, developers quickly built libraries to simplify the common case. The most used was the\n      "),a("a",{attrs:{href:"http://api.jquery.com/jQuery.getJSON/"}},[a("code",[e._v(".getJSON()")])]),e._v(" method that was added to the popular\n      "),a("a",{attrs:{href:"https://jquery.com/"}},[e._v("jQuery library")]),e._v(". It replaced the code above with this:")]),a("pre",[a("code",{staticClass:"javascript language-javascript"},[e._v('//assuming that the jQuery library has been added to the page...\n//second parameter is a function to be called when the request\n//is complete and the data has been returned\n$.getJSON("/my/data/url", function(data) {\n    //`data` is the already-parsed JSON data returned from the server\n});')])]),a("p",[e._v("This was a much easier programming interface, but it required the entire jQuery library to be included in the page, which added another\n      "),a("code",[e._v("87KB")]),e._v(" of script to your application. And since\n      "),a("a",{attrs:{href:"http://youmightnotneedjquery.com/"}},[e._v("the need for the jQuery library has largely gone away")]),e._v(", developers started asking for something like the jQuery\n      "),a("code",[e._v(".getJSON()")]),e._v(" method to be built-in to the browser as a native API.")]),a("p",[e._v("The result was the\n      "),a("code",[e._v("fetch()")]),e._v(" API, which is\n      "),a("a",{attrs:{href:"http://caniuse.com/#feat=fetch"}},[e._v("now supported in all major browsers except IE 11 and Safari 10")]),e._v(". For those browsers, we just have to add\n      "),a("a",{attrs:{href:"https://github.com/github/fetch"}},[e._v("a small polyfill library")]),e._v(" that implements the\n      "),a("code",[e._v("fetch()")]),e._v(" function using the existing\n      "),a("code",[e._v("XMLHttpRequest")]),e._v(" object.")]),a("p",[e._v("A\n      "),a("strong",[e._v("polyfill")]),e._v(" library is one that adds a feature that is not yet supported natively by the browser by implementing that feature in JavaScript using existing functionality. The fetch polyfill implements the new\n      "),a("code",[e._v("fetch()")]),e._v(" function using the existing\n      "),a("code",[e._v("XMLHttpRequest")]),e._v(" interface. If the library detects the native implementation, it simply exits and does nothing.")]),a("p",[e._v("To add the\n      "),a("code",[e._v("fetch()")]),e._v(" polyfill library from\n      "),a("a",{attrs:{href:"https://cdnjs.com/libraries/fetch"}},[e._v("its CDN")]),e._v(", simply include this\n      "),a("code",[e._v("script")]),e._v(" element in your HTML page,\n      "),a("em",[e._v("before")]),e._v(" any script where you use the\n      "),a("code",[e._v("fetch()")]),e._v(" function:")]),a("pre",[a("code",{staticClass:"html language-html"},[e._v('\x3c!-- fetch() polyfill, version 2.0.1 --\x3e\n\x3c!-- for the most recent version, see https://cdnjs.com/libraries/fetch --\x3e\n<script src="https://cdnjs.cloudflare.com/ajax/libs/fetch/2.0.1/fetch.min.js"><\/script>\n\n\x3c!-- your script --\x3e\n<script src="js/app.js"><\/script>')])]),a("h2",{attrs:{id:"sec-asynchronousrequestsandpromises"}},[e._v("Asynchronous Requests and Promises")]),a("p",[e._v("Because HTTP requests are done asynchronously, the\n      "),a("code",[e._v("fetch()")]),e._v(" function returns an object known as a\n      "),a("strong",[e._v("Promise")]),e._v(". A Promise represents an asynchronous operation that will eventually complete successfully or fail. A Promise allows developers to add functions that should be called when either of those conditions occurs. These are just like event listeners, except there are only two events: success (aka resolve), and fail (aka reject). So the Promise object provides two different methods, one for registering a success listener (\n      "),a("code",[e._v(".then()")]),e._v("), and one for registering a failure listener (\n      "),a("code",[e._v(".catch()")]),e._v(").")]),a("p",[e._v("To fetch a URL, call the\n      "),a("code",[e._v("fetch()")]),e._v(" function passing the URL you want to fetch. It returns a Promise, which you can use to register a callback function that will be invoked when the server responds:")]),a("pre",[a("code",{staticClass:"javascript language-javascript"},[e._v('var promise = fetch("/my/data/url");\n\n//add a function to be called when the request completes successfully\npromise.then(function(response) {\n    //parse response as JSON\n    return response.json();\n});')])]),a("p",[e._v("Declaring that intermediate variable\n      "),a("code",[e._v("promise")]),e._v(" is unnecessary in JavaScript, so we typically combine those two statements above into one:")]),a("pre",[a("code",{staticClass:"javascript language-javascript"},[e._v('fetch("/my/data/url").then(function(response) {\n    //parse response as JSON\n    return response.json();\n});')])]),a("p",[e._v("And to make the code a bit more readable, we typically insert a line break after the call to\n      "),a("code",[e._v("fetch()")]),e._v(" and before the call to the Promise's\n      "),a("code",[e._v(".then()")]),e._v(" method:")]),a("pre",[a("code",{staticClass:"javascript language-javascript"},[e._v('fetch("/my/data/url")\n    .then(function(response) {\n        //this is called after the server responds to our request\n        //parse response as JSON\n        return response.json();\n    });')])]),a("p",[e._v("The function we pass to the Promise's\n      "),a("code",[e._v(".then()")]),e._v(" method will be called once the server begins to respond. The\n      "),a("code",[e._v("response")]),e._v(" object passed to this function as the first parameter allows us to do several things, but most commonly, you will want to parse the response body as JSON-encoded data. To do that, simply\n      "),a("code",[e._v("return response.json()")]),e._v(".")]),a("p",[e._v("The\n      "),a("code",[e._v("response.json()")]),e._v(" method is another asynchronous operation, so it actually returns a new Promise as well. But the neat thing about promises is that if you return a new Promise from a\n      "),a("code",[e._v(".then()")]),e._v(" callback function, the outer Promise will take on the state of the new returned Promise. That allows us to add another\n      "),a("code",[e._v(".then()")]),e._v(" callback function, which will be called once the JSON parsing has completed:")]),a("pre",[a("code",{staticClass:"javascript language-javascript"},[e._v('fetch("/my/data/url")\n    .then(function(response) {\n        //parse response as JSON\n        return response.json();\n    })\n    .then(function(data) {\n        //this is called after the JSON parsing is complete\n        //`data` will be the parsed data (Object or Array)\n        console.log(data)\n    });')])]),a("p",[e._v("The return value of the first\n      "),a("code",[e._v(".then()")]),e._v(" method is the same Promise object, so syntactically we can keep chaining\n      "),a("code",[e._v(".then()")]),e._v(" methods, one after the other.")]),a("p",[e._v("All of this code so far assumes that the network request completes successfully, but when computer networks are involved, you should always assume that the request could fail. The client's WiFi connection might be down, or their connection to their ISP could be down, or the server could be down.")]),a("p",[e._v("To respond to a network failure, we can use the Promise's\n      "),a("code",[e._v(".catch()")]),e._v(" method to register a function that will be called if the request fails. Your function will be handed an\n      "),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error"}},[e._v("Error object")]),e._v(" as the first parameter, which will contain details about the error.")]),a("pre",[a("code",{staticClass:"javascript language-javascript"},[e._v('fetch("/my/data/url")\n    .then(function(response) {\n        return response.json();\n    })\n    .then(function(data) {\n        console.log(data)\n    })\n    .catch(function(err) {\n        //write the full error object to the console\n        console.error(err);\n\n        //show the error message to the user\n        //you could instead set the `.textContent` of some\n        //DOM element you use to show errors\n        alert(err.message);\n    });')])]),a("p",[e._v("The really nice thing about Promises is that the function we pass to\n      "),a("code",[e._v(".catch()")]),e._v(" will be called if any error occurs either during the fetch, or in the JSON parsing. If any of the functions passed to\n      "),a("code",[e._v(".then()")]),e._v(" cause an error to occur, execution will automatically jump to your\n      "),a("code",[e._v(".catch()")]),e._v(" function, skipping any intermediary\n      "),a("code",[e._v(".then()")]),e._v(" functions. This allows you to centralize your error handling in one place, and avoid calling code that depends upon the previous code executing without errors.")]),a("h2",{attrs:{id:"sec-tryingitout"}},[e._v("Trying it Out")]),a("p",[e._v("There are\n      "),a("a",{attrs:{href:"https://www.programmableweb.com/"}},[e._v("many, many sources of live data on the web")]),e._v(", but the one we will use for a quick demo, and for your challenge, is the\n      "),a("a",{attrs:{href:"https://data.seattle.gov"}},[e._v("data.seattle.gov")]),e._v(" site. This site hosts public data for the city of Seattle, and one interesting dataset is the\n      "),a("a",{attrs:{href:"https://data.seattle.gov/Transportation/Fremont-Bridge-Hourly-Bicycle-Counts-by-Month-Octo/65db-xm6k"}},[e._v("hourly bicycle traffic counts across the Fremont bridge")]),e._v(".")]),a("p",[e._v("All of the datasets on the site can be returned in JSON format, and you can supply extra parameters on the URL to filter and sort the data. For example, this URL will return the most-recent 24 hours of data. Click on the URL to see the JSON data in your browser.")]),a("blockquote",[a("p",[a("a",{attrs:{href:"https://data.seattle.gov/resource/4xy5-26gy.json?$order=date%20desc&$limit=24"}},[e._v("https://data.seattle.gov/resource/4xy5-26gy.json?$order=date%20desc&$limit=24")]),e._v(";")])]),a("p",[e._v("You can see that it returns an array of objects, one for each hour. The objects have three properties each:\n      "),a("code",[e._v("date")]),e._v(" (date and time of observation),\n      "),a("code",[e._v("fremont_bridge_nb")]),e._v(" (number of bikes traveling on the east sidewalk), and\n      "),a("code",[e._v("fremont_bridge_sb")]),e._v(" (number of bikes traveling on the west sidewalk).")]),a("p",[e._v("Once we fetch this data and parse it as JSON, we can render it to an HTML table, similar to how to rendered the\n      "),a("code",[e._v("people")]),e._v(" array in the previous tutorial, or the\n      "),a("code",[e._v("MOVIES")]),e._v(" array in the previous challenge. ")]),a("pre",[a("code",{staticClass:"javascript language-javascript"},[e._v('//last 24-hours of data from Fremont Bridge bike traffic\nvar dataURL = "https://data.seattle.gov/resource/4xy5-26gy.json?$order=date%20desc&$limit=24";\n\nfunction parseAsJSON(response) {\n    return response.json();\n}\n\nfunction handleError(err) {\n    console.error(err);\n    alert(err.message);\n}\n\nfunction renderRecord(record) {\n    //create a <tr> and <td> elements for each property\n    //...\n}\n\nfunction renderTable(data) {\n    //`data` is an array of objects\n    //loop over the array calling renderRecord()\n    //for each record, and appending the returned\n    //<tr> to the <tbody>\n    //...\n}\n\n//fetch the data\nfetch(dataURL)\n    .then(parseAsJSON)\n    .then(renderTable)\n    .catch(handleError);')])]),a("p",[e._v("Because the parsing as JSON and handling of errors is something that will be similar for all\n      "),a("code",[e._v("fetch()")]),e._v(" requests, it makes sense to define these functions once and simply pass a reference to them to the\n      "),a("code",[e._v(".then()")]),e._v(" and\n      "),a("code",[e._v(".catch()")]),e._v(' methods. I also defined a function for the table rendering, similar to what we had done before. When passing just the function names (i.e., references), it makes the Promise chain read almost like English: "fetch this URL, then parse it as JSON, then render it to a table, and handle any errors that happen along the way."')]),a("p",[e._v("To see this in action, visit\n      "),a("a",{attrs:{href:"https://codepen.io/nickdenardis/pen/YLYgLx"}},[e._v("my fetch example on CodePen")]),e._v(".")])])}]};t.a=r},"ZKf+":function(e,t,a){"use strict";t.a={head:{title:"Javascript AJAX"},mounted:function(){Prism.highlightAll()}}},m9iS:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=a("ZKf+"),r=a("XAv9"),o=a("VU/8")(n.a,r.a,!1,null,null,null);o.options.__file="pages/javascript-ajax.vue",t.default=o.exports}});