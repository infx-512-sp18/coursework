webpackJsonp([12],{"2cM9":function(e,t,n){"use strict";var a=function(){var e=this.$createElement;this._self._c;return this._m(0)};a._withStripped=!0;var o={render:a,staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("main",{attrs:{id:"main",tabindex:"-1"}},[n("h1",[e._v("DOM manipulation")]),n("p",[n("iframe",{attrs:{width:"560",height:"315",src:"https://www.youtube.com/embed/tIahi41c7ds?rel=0",frameborder:"0",allow:"autoplay; encrypted-media",allowfullscreen:""}})]),n("p",[e._v("Now that you know the basics of the JavaScript language, we can learn how to use that language to add some interactivity to our web pages. Specifically, we will learn how to respond to user interactions, modify the contents of elements, and add/remove style classes to alter formatting.")]),n("h2",{attrs:{id:"sec-addingscriptstothepage"}},[e._v("Adding Scripts to the Page")]),n("p",[e._v("The browser only knows about the HTML page it loads, and other files that it links to. So to add some script to our web page, we need to add an element that points to the script file. That element looks like this:")]),n("pre",[n("code",{staticClass:"html language-html"},[e._v('<script src="path/to/javascript/file.js"><\/script>')])]),n("p",[e._v("Strangely enough, you do need both a start and end tag, even though the element should have no content. The\n      "),n("code",[e._v("src")]),e._v(" attribute can be an absolute or relative URL to your script file. Absolute paths are typically used when loading a library of functions from a CDN location, while a relative path will be used to load your own JavaScript files from a\n      "),n("code",[e._v("js")]),e._v(" sub-folder.")]),n("p",[e._v("You can add as many\n      "),n("code",[e._v("<script>")]),e._v(" elements to a page as you want. The browser will download and execute each script in order, and they all will share a common global name space. So if the first script defines a global variable or function, scripts added after that one will also be able to reference that variable, or call that function, defined in the previous script.")]),n("p",[e._v("Because the browser pauses to download and execute scripts when it encounters them, we typically put these\n      "),n("code",[e._v("<script>")]),e._v(" elements at the end of the\n      "),n("code",[e._v("<body>")]),e._v(" section, just before the\n      "),n("code",[e._v("</body>")]),e._v(" tag. That way the page content will render and the user can click on hyperlinks while the scripts are still downloading.")]),n("p",[e._v("Most browsers now support adding a\n      "),n("code",[e._v("defer")]),e._v(" attribute to the\n      "),n("code",[e._v("<script>")]),e._v(" element that tells the browser to defer downloading and running the script until the page is fully loaded and rendered to the screen. With this attribute, you can put the\n      "),n("code",[e._v("<script>")]),e._v(" element anywhere in the page. But beware about this for the short-term: it's\n      "),n("a",{attrs:{href:"http://caniuse.com/#feat=script-defer"}},[e._v("not supported in older browsers")]),e._v(" like IE 8. Those browsers will simply download and execute the script as soon as they encounter the\n      "),n("code",[e._v("<script>")]),e._v(" element.")]),n("h2",{attrs:{id:"sec-thedocumentobjectmodeldom"}},[e._v("The Document Object Model (DOM)")]),n("p",[e._v('When the browser executes a script, it adds a few objects to the global name space that are just "there." You don\'t have to create these objects or load them from anywhereâ€”they are simply available because the browser added them before running your script.')]),n("p",[e._v("These global objects, and the objects they link to, are known as the\n      "),n("a",{attrs:{href:"http://www.w3schools.com/js/js_htmldom.asp"}},[e._v("Document Object Model (DOM)")]),e._v(". The DOM contains a JavaScript object for each element in your web page, organized in a tree data structure just like the elements. The root of that tree is accessible via a browser-supplied global variable named\n      "),n("code",[e._v("document")]),e._v(". That variable is an object that represents the entire page, and it has many properties and methods you can use to traverse, interrogate, and even manipulate the elements within then page.")]),n("h3",{attrs:{id:"sec-gettingreferencestoelements"}},[e._v("Getting References to Elements")]),n("p",[e._v("To interrogate or manipulate an element in your page, you first need to get a reference to the corresponding\n      "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/element"}},[e._v("DOM Element object")]),e._v(" that the browser created for that element when it parsed the page. This can be done using one of two methods.")]),n("p",[e._v("If the element you want to interact with has an\n      "),n("code",[e._v("id")]),e._v(" attribute, you can use\n      "),n("code",[e._v("document.getElementById()")]),e._v(" to get a reference to it. For example, this line of code would get a reference to the element with an\n      "),n("code",[e._v("id")]),e._v(" attribute set to\n      "),n("code",[e._v("first-name-input")]),e._v(":")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('var nameInput = document.getElementById("first-name-input");')])]),n("p",[e._v("This method works only for elements with an\n      "),n("code",[e._v("id")]),e._v(" attribute, but there's another much more flexible and powerful method that will let you select elements using the same CSS selector syntax you've already learned. The method is\n      "),n("code",[e._v("document.querySelector()")]),e._v(", and this is how you would use it to select the first element with the style class\n      "),n("code",[e._v("output-paragraph")]),e._v(":")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('var outputPara = document.querySelector(".output-paragraph");')])]),n("p",[e._v("The\n      "),n("code",[e._v("document.querySelector()")]),e._v(" method accepts any sort of CSS selector: element, ID, class, descendant, group, etc. For example, this selector will find the\n      "),n("code",[e._v("<tbody>")]),e._v(" element that exists within an element with the style class\n      "),n("code",[e._v("output-table")]),e._v(":")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('var outputTableBody = document.querySelector(".output-table tbody");')])]),n("p",[e._v("Note that\n      "),n("code",[e._v("document.querySelector()")]),e._v(" finds only\n      "),n("em",[e._v("the first")]),e._v(" element that satisfies that selector. To get\n      "),n("em",[e._v("all")]),e._v(" elements that satisfy the given selector, use\n      "),n("code",[e._v("document.querySelectorAll()")]),e._v(". That method will return a\n      "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/NodeList"}},[e._v("NodeList object")]),e._v(", which is like an array, but not quite. It has a\n      "),n("code",[e._v(".length")]),e._v(" property and you can retrieve an element by index, but it doesn't support all the other methods that JavaScript arrays currently support. The safest way to iterate a\n      "),n("code",[e._v("NodeList")]),e._v(" at the present time is to use a standard\n      "),n("code",[e._v("for")]),e._v(" loop:")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('//select all hyperlink elements\nvar links = document.querySelectorAll("a");\n\n//for each link returned...\nvar idx;\nfor (idx = 0; idx < links.length; idx++) {\n    //set its `target` attribute to "_blank"\n    //so that it automatically opens in a new browser tab\n    links[idx].target = "_blank";\n}')])]),n("h3",{attrs:{id:"sec-gettingsettingthecontentofanelement"}},[e._v("Getting/Setting The Content of an Element")]),n("p",[e._v("Once you have a reference to an element, you can do several things with it. First, you can get or set its content using the\n      "),n("code",[e._v("textContent")]),e._v(" property:")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('//get a reference to the first element that has the style class `alert`\nvar alert = document.querySelector(".alert");\n\n//get the existing text content (just to demonstrate)\nconsole.log(alert.textContent)\n\n//reset the text content--this will update the element\'s text on screen\nalert.textContent = "This is a new alert message!";')])]),n("p",[e._v("The\n      "),n("code",[e._v("textContent")]),e._v(' property is considered "safe," meaning that if you try to set it to a string that contains HTML, the browser will not interpret the string as HTML, and will instead display the HTML as plain text inside the element. This is a good thing. When we build web applications, these strings often come from the user in the first place, and devious users will often try to enter crafty HTML that when executed, can steal private information from a user. This is known as a\n      '),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Code_injection"}},[e._v("Code Injection Attack")]),e._v(", and it can be avoided by using this\n      "),n("code",[e._v("textContent")]),e._v(" property when setting an element's content.")]),n("p",[e._v("There is another property named\n      "),n("code",[e._v("innerHTML")]),e._v(" that is not safe. It sets the element's content, but that content will be interpreted as HTML, and may result in code being executed. This is generally not a good property to use unless you are absolutely certain the content came from a trusted source.")]),n("p",[e._v("You can also clear the content within an element by setting the\n      "),n("code",[e._v("textContent")]),e._v(" or\n      "),n("code",[e._v("innerHTML")]),e._v(" properties to an empty string:")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('//get a reference to the first element that has the style class `alert`\nvar alert = document.querySelector(".alert");\n\n//clear the content\nalert.textContent = "";')])]),n("h3",{attrs:{id:"sec-gettingsettingattributes"}},[e._v("Getting/Setting Attributes")]),n("p",[e._v("You can also get or set any attributes that might be supported by an element you select. Each attribute is typically exposed as a property of the returned element. So if you want to change the\n      "),n("code",[e._v("src")]),e._v(" attribute of an\n      "),n("code",[e._v("img")]),e._v(" element to show a different picture, you would use code like this:")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('//get a reference to the image element\nvar img = document.querySelector("img");\n\n//reset it\'s `src` attribute to load a different image\nimg.src = "https://...."')])]),n("p",[e._v("If you want to get all attributes, or if you're not sure which attributes are available on the element, use the\n      "),n("code",[e._v(".attributes")]),e._v(" property, which returns a\n      "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap"}},[e._v("NamedNodeMap")]),e._v(" object. This isn't commonly necessary, but it can be handy in cases where you are trying to write code that works with any kind of element.")]),n("h3",{attrs:{id:"sec-gettingsettingthevalueofaninput"}},[e._v("Getting/Setting the Value of an Input")]),n("p",[e._v("The\n      "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input"}},[n("code",[e._v("<input>")])]),e._v(" element is used for gather input from the user, but it is a self-closing tag, and thus doesn't have any content. The value the user types into the input is actually stored in a\n      "),n("code",[e._v("value")]),e._v(" property which you can get or set. This property is updated every time the user types into the input.")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('//get a reference to the input with the class name `name-input`\nvar nameInput = document.querySelector(".name-input");\n\n//get the string the user has typed into that input\nconsole.log(nameInput.value);\n\n//clear the input\nnameInput.value = "";')])]),n("h3",{attrs:{id:"sec-gettingsettingtheselectedoptionofaselect"}},[e._v("Getting/Setting the Selected Option of a Select")]),n("p",[e._v("The\n      "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select"}},[n("code",[e._v("<select>")])]),e._v(" and\n      "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option"}},[n("code",[e._v("<option>")])]),e._v(" elements are used to let the user choose from a fixed list of available options. The associated DOM element also has a\n      "),n("code",[e._v("value")]),e._v(" property which you can use to get the\n      "),n("code",[e._v("value")]),e._v(" attribute of the selected\n      "),n("code",[e._v("<option>")]),e._v(" element. But if you want to get the display text of the\n      "),n("code",[e._v("<option>")]),e._v(" element instead, you can use the\n      "),n("code",[e._v(".selectedIndex")]),e._v(" property to get the selected option's index, and then access the option element object to get its content:")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('//get a reference to the input with the class name `state-select`\nvar stateSelect = document.querySelector(".state-select");\n\n//get the `value` attribute of the selected option\nconsole.log(stateSelect.value);\n\n\n//get the display text of that selected option instead\nconsole.log(stateSelect.options.item(stateSelect.selectedIndex).textContent);')])]),n("h3",{attrs:{id:"sec-addingremovingstyleclasses"}},[e._v("Adding/Removing Style Classes")]),n("p",[e._v("In addition to manipulating the content of element, you can also alter its formatting via JavaScript. The best way to do this is to add or remove CSS style classes that are defined in your stylesheet. Adding a new class to an element is done like so:")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('var p = document.querySelector("p");\n\n//show all existing style classes on the element\nconsole.log(p.className);\n\n//add the `my-style-class` to the set of classes\np.classList.add("my-style-class");\n\n//will now include the new style class at the end\nconsole.log(p.className);')])]),n("p",[e._v("Removing a style class is done using\n      "),n("code",[e._v(".classList.remove()")]),e._v(".")]),n("p",[e._v("If you want to modify just one specific style property and leave the list of style classes alone, you can do that using the element's\n      "),n("code",[e._v(".style")]),e._v(" property. For example, this change the element's\n      "),n("code",[e._v("background-color")]),e._v(" style (note the name in JavaScript is\n      "),n("code",[e._v("backgroundColor")]),e._v("):")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('p.style.backgroundColor = "#CCCCCC";')])]),n("h2",{attrs:{id:"sec-listeningforevents"}},[e._v("Listening for Events")]),n("p",[e._v("All of this manipulation is neat, but you typically want to perform this manipulation\n      "),n("em",[e._v("in response")]),e._v(" to some kind of user interaction: clicking, typing, scrolling, etc. Since these events occur after the page has loaded, and after your script has run, you need to ask the browser to call some of your code whenever these events occur. You can do that using the element's\n      "),n("code",[e._v(".addEventListener()")]),e._v(" method.")]),n("p",[e._v("For example, say you have a\n      "),n("code",[e._v("<button>")]),e._v(" element in your page, and you want the browser to run some code whenever the user clicks that button. You first get a reference to the DOM Element object for that button, and then pass a function reference to its\n      "),n("code",[e._v(".addEventListener()")]),e._v(" method:")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('//this function should be called each time\n//the user clicks the button\nfunction onButtonClick() {\n    console.log("my button was clicked!");\n}\n\n//get a reference to the button element\nvar button = document.querySelector("button");\n\n//tell the browser to call my onButtonClick() function\n//whenever the "click" event occurs\nbutton.addEventListener("click", onButtonClick);')])]),n("p",[e._v("Each time the user clicks the button, the browser will call your\n      "),n("code",[e._v("onButtonClick()")]),e._v(" function. In that function you can select other elements, manipulate their content, or add/remove style classes.")]),n("p",[e._v("Note that the second parameter to\n      "),n("code",[e._v(".addEventListener()")]),e._v(" is just the name of the function with no parentheses after it. That name is like a variable name. It\n      "),n("em",[e._v("refers")]),e._v(" to the function. Putting parentheses after the name would\n      "),n("em",[e._v("call")]),e._v(" the function, and pass the function's return value as the second parameter to\n      "),n("code",[e._v(".addEventListener()")]),e._v(", which is not what you want. When registering an event listener, always pass a function\n      "),n("em",[e._v("reference")]),e._v("; don't\n      "),n("em",[e._v("call")]),e._v(" the function. You want the browser to call your function later. Passing the function reference to the browser allows it to call your function whenever the event occurs.")]),n("p",[e._v("You can alternatively provide the event listener function in-line if you want to, and this is commonly done in the JavaScript world. Instead of defining the event listener as a function with a name, and passing that name as a function reference, you can provide an\n      "),n("strong",[e._v("inline anonymous function")]),e._v(":")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('//get a reference to the button element\nvar button = document.querySelector("button");\n\n//tell the browser to call the inline anonymous function\n//whenever the "click" event occurs\nbutton.addEventListener("click", function() {\n    console.log("my button was clicked!");\n});')])]),n("p",[e._v("Notice that we simply moved the function declaration down into the spot where we had previously used the function name. This is known as a\n      "),n("strong",[e._v("function value")]),e._v(" and it doesn't need a name anymore, as the function is declared and passed as a reference in one operation.")]),n("p",[e._v("Either approach works, but the latter is more compact and doesn't require naming the function, so it's commonly used by professionals.")]),n("p",[e._v("As the name implies,\n      "),n("code",[e._v(".addEventListener()")]),e._v(" will\n      "),n("em",[e._v("add")]),e._v(" a function to the list of listeners for that event. You can add multiple functions for the same event, and the browser will call all of them, in the order they were added. ")]),n("p",[e._v("This is good for code re-use: JavaScript libraries can safely add event listeners without having to coordinate with other code that might be added to the same page. Initially, the DOM supported only one event listener for a given element, and the listener was registered by setting a property named\n      "),n("code",[e._v("onEventName")]),e._v(", where\n      "),n("code",[e._v("EventName")]),e._v(" was the name of the event you wanted to listen for. If another bit of script reset that property, the browser would only call the newly set function, and the previous one as well. The\n      "),n("code",[e._v(".addEventListener()")]),e._v(" method was added to fix this problem, so it's good practice to use it.")]),n("p",[e._v("The\n      "),n("code",[e._v(".addEventListener()")]),e._v(" also enabled something the previous mechanism didn't support at all: adding a listener that should be called only once for the next occurrence of the event. This is handy when you need to clean up something after an asynchronous operation is complete (e.g.,\n      "),n("a",{attrs:{href:"#sec-animationevents"}},[e._v("an element animation")]),e._v("). To register a one-time event listener, just pass a JavaScript object with a property named\n      "),n("code",[e._v("once")]),e._v(" set to\n      "),n("code",[e._v("true")]),e._v(" as the third parameter:")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('//tell the browser to call the inline function\n//only once after the next click\nbutton.addEventListener("click", function() {\n    console.log("my button was clicked!");\n}, {once: true});')])]),n("h2",{attrs:{id:"sec-commonlyusedevents"}},[e._v("Commonly-Used Events")]),n("p",[e._v("For a full list of events you can listen for, see the\n      "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/Events"}},[e._v("Event Reference")]),e._v(", but the following sections describe several of the most commonly-used events.")]),n("h3",{attrs:{id:"sec-mouseevents"}},[e._v("Mouse Events")]),n("p",[e._v("Every HTML element will raise a\n      "),n("code",[e._v('"click"')]),e._v(" event when the element is clicked. This will also occur on touch screens when the element is tapped, though after a very short delay. Touch screens will also raise\n      "),n("code",[e._v("touchstart")]),e._v(" and\n      "),n("code",[e._v("touchend")]),e._v(" events when the user starts and stops touching an element.")]),n("p",[e._v("Elements also raise a\n      "),n("code",[e._v('"doubleclick"')]),e._v(" event when the element is double-clicked/tapped, and\n      "),n("code",[e._v('"contextmenu"')]),e._v(" when the user clicks with the alternate button.")]),n("h3",{attrs:{id:"sec-windowevents"}},[e._v("Window Events")]),n("p",[e._v("When the user scrolls the page, the\n      "),n("code",[e._v("window")]),e._v(" object (another global like\n      "),n("code",[e._v("document")]),e._v(") will raise a\n      "),n("code",[e._v('"scroll"')]),e._v(" event. This allows you to alter the page as the user scrolls down. For example, a navigation bar might start scrolling with the overall page, but become fixed to the top of the viewport once it reaches the top of the viewport.")]),n("p",[e._v("If the user resizes the browser window, the\n      "),n("code",[e._v("window")]),e._v(" object will raise a\n      "),n("code",[e._v('"resize"')]),e._v(" event. This allows you to adjust your page layout in ways that go beyond what you can do with CSS media rules.")]),n("h3",{attrs:{id:"sec-inputevents"}},[e._v("Input Events")]),n("p",[e._v("As noted earlier,\n      "),n("code",[e._v("<input>")]),e._v(" elements create a box into which users can enter text. These elements raise an event named\n      "),n("code",[e._v('"input"')]),e._v(" whenever the contents of the box is changed by the user. This happens with each keystroke, so it's a handy way to respond as the user types:")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('var fNameInput = document.querySelector(".first-name-input");\n\nfNameInput.addEventListener("input", function() {\n    console.log("user typed:", fNameInput.value);\n});')])]),n("p",[e._v("These elements raise another event name\n      "),n("code",[e._v('"change"')]),e._v(', but this fires only when the user tabs or clicks out of the input box (known as "losing focus"). This event can be useful when you want to let the user type a longer bit of text and only process it once the user leaves the input.')]),n("h3",{attrs:{id:"sec-animationevents"}},[e._v("Animation Events")]),n("p",[e._v("Adding a style class that refers to an\n      "),n("a",{attrs:{href:"https://daneden.github.io/animate.css/"}},[e._v("animation")]),e._v(" will cause the browser to animate the element asynchronously. But if you try to add that same style class again to the element, the browser will simply ignore that operation, as the class already exists on the element. Attempting to remove the class and add it again in two successive lines won't work either, as the browser will wait to look for style class changes until your event listener function completes.")]),n("p",[e._v("To trigger an animation repeatedly, you must listen for the\n      "),n("code",[e._v('"animationend"')]),e._v(" event that will be raised once the browser has finished animating the element. During this event, your code can remove the style class. That way, the next time you add that style class, the browser will notice that it wasn't there before, and animate the element again.")]),n("p",[e._v("For example, this code adds the\n      "),n("code",[e._v("bounce")]),e._v(" animation style class from the\n      "),n("a",{attrs:{href:"https://daneden.github.io/animate.css/"}},[e._v("animate.css")]),e._v(" stylesheet to an element each time a button is clicked:")]),n("pre",[n("code",{staticClass:"javascript language-javascript"},[e._v('//assuming the animate.css stylesheet is included in the page\n//and thus their animation style classes are defined...\n\n//select the element to animate\nvar animateElem = document.querySelector(".elem-to-animate");\n\n//when the animate button is clicked...\nvar animateButton = document.querySelector(".animate-button");\nanimateButton.addEventListener("click", function() {\n    //add the `bounce` style class to trigger a bounce animation\n    animateElem.classList.add("bounce");\n\n    //when the animation ends, remove that `bounce` style class\n    animateElem.addEventListener("animationend", function() {\n        animateElem.classList.remove("bounce");\n    }, {once: true});\n});')])]),n("p",[e._v("Note that I added the\n      "),n("code",[e._v("{once: true}")]),e._v(" as a third parameter to the\n      "),n("code",[e._v("addEventListener()")]),e._v(" method. This tells the browser that I only want this function to run for the next\n      "),n("code",[e._v('"animationend"')]),e._v(" event, and not when that event occurs again in the future. The browser will call my event listener the next time that\n      "),n("code",[e._v('"animationend"')]),e._v(" event occurs, but after my event listener function exits, the browser will remove my listener so that it's not called again in the future. This is a handy way to clean up after an asynchronous operation, such as a CSS animation, completes.")]),n("h2",{attrs:{id:"sec-conclusion"}},[e._v("Conclusion")]),n("p",[e._v("The DOM plus the ability to add event listener functions gives us total control over our web pages. We can literally rewrite the page in response to user interactions, which allows us to build highly-interactive web sites and applications.")]),n("p",[e._v("Now try some of this yourself. Use\n      "),n("a",{attrs:{href:"https://codepen.io/nickdenardis/pen/xjXoaX"}},[e._v("this CodePen")]),e._v(" or create your own page and script.")])])}]};t.a=o},"8sqn":function(e,t,n){"use strict";t.a={head:{title:"DOM manipulation"},mounted:function(){Prism.highlightAll()}}},BLy7:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=n("8sqn"),o=n("2cM9"),s=n("VU/8")(a.a,o.a,!1,null,null,null);s.options.__file="pages/javascript-dom.vue",t.default=s.exports}});